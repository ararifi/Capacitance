macro partitionPrivate(meshName, borderName, globalName, PhGlobalPrivate, VhGlobalPrivate, part, rank, size, s, overlap, level, prolongation, D, P, intersection, comm, fakeInterface, PkPart, defPart, initPart, bs) {
    int backupSM = searchMethod;
    searchMethod = 1;
    assert(level >= 1);
IFMACRO(!privateCreatePartition)
IFMACRO(!privateCreateMat)
    intersection.resize(1);
    intersection[0].resize(0);
    PhGlobalPrivate supp;
    VhGlobalPrivate suppSmooth;
    {
        int constant = rank;
        for[i, v : supp[]] v = abs(part[][i] - constant) < 0.1;
        AddLayers(globalName, supp[], 2 * overlap, suppSmooth[]);
        int[int] n2o;
        meshN neighbors;
        bool connected = false;
        for[i, v : suppSmooth[]] if(abs(v - 0.5) < 0.5) connected = true;
        if(!connected)
            n2o.resize(0);
        else
            neighbors = trunc(globalName, suppSmooth > 0.001 && suppSmooth < 0.999, new2old = n2o);
        int[int] partOverlap(n2o.n);
        for[i, v : n2o] partOverlap[i] = part[][v];
        Unique(partOverlap, intersection[0], remove = constant);
        if(s > 1 && level <= 1) {
            globalName = trunc(globalName, suppSmooth > 0.001, split = s);
            supp = abs(part - constant) < 0.1;
            suppSmooth = 0;
            AddLayers(globalName, supp[], 2 * overlap, suppSmooth[]);
        }
    }
    int[int] n2oGlobalPrivate, n2oNeighbor;
IFMACRO(!privateDmesh#CartesianPartitioning)
    globalName = trunc(globalName, suppSmooth > 0.001, label = 9999, new2old = n2oGlobalPrivate);
ENDIFMACRO
    real eps = globalName.measure;
    real[int] epsTab(intersection[0].n);
    mpiRequest[int] rq(2 * intersection[0].n);
    if(mpiSize(comm) == size) {
        for(int j = 0; j < intersection[0].n; ++j)
            Irecv(processor(intersection[0][j], comm, rq[j]), epsTab[j]);
        for(int j = 0; j < intersection[0].n; ++j)
            Isend(processor(intersection[0][j], comm, rq[intersection[0].n + j]), eps);
    }
    else
        epsTab = 1.0e+30;
    suppSmooth = suppSmooth;
IFMACRO(!privateDmesh#N2O)
    meshName[level - 1] = trunc(globalName, suppSmooth > 0.501, label = fakeInterface, new2old = n2oNeighbor);
IFMACRO(privateDmesh#CartesianPartitioning)
    real[int] bb(2 * dimension);
    boundingbox(meshName[level - 1], bb);
    meshName[level - 1] = trunc(globalName, x > bb[0] && x < bb[1] && y > bb[2] && y < bb[3]
IFMACRO(dimension,3)
                                                                                             && z > bb[4] && z < bb[5]
ENDIFMACRO
                                                                                                                      , label = fakeInterface);
    globalName = meshName[level - 1];
    n2oNeighbor = 0:globalName.nt - 1;
ENDIFMACRO
ENDIFMACRO
IFMACRO(privateDmesh#N2O)
    meshName[level - 1] = trunc(globalName, suppSmooth > 0.501, label = fakeInterface, new2old = privateDmesh#N2O);
IFMACRO(privateDmesh#CartesianPartitioning)
    real[int] bb(2 * dimension);
    boundingbox(meshName[level - 1], bb);
    meshName[level - 1] = trunc(globalName, x > bb[0] && x < bb[1] && y > bb[2] && y < bb[3]
IFMACRO(dimension,3)
                                                                                             && z > bb[4] && z < bb[5]
ENDIFMACRO
                                                                                                                      , label = fakeInterface, new2old = privateDmesh#N2O);
    globalName = meshName[level - 1];
    n2oNeighbor = 0:globalName.nt - 1;
ENDIFMACRO
IFMACRO(!privateDmesh#CartesianPartitioning)
    {
        int[int] backup = privateDmesh#N2O;
        int[int] new = n2oGlobalPrivate(privateDmesh#N2O);
        privateDmesh#N2O.resize(new.n);
        privateDmesh#N2O = new;
        n2oNeighbor.resize(backup.n);
        n2oNeighbor = backup;
    }
ENDIFMACRO
ENDIFMACRO
    if(level > 1) {
        prolongation.resize(level - 1);
        if(s > 1) {
            meshN globalNameRefined = globalName;
            for(int i = level - 1; i > 0; --i) {
                globalNameRefined = trunc(globalNameRefined, 1, split = s);
                meshName[i - 1] = trunc(globalNameRefined, suppSmooth > 0.501, label = fakeInterface);
                fespace WhLocalRefinedPrivate(meshName[i - 1], P);
                fespace WhLocalCoarsePrivate(meshName[i], P);
                prolongation[i - 1] = interpolate(WhLocalRefinedPrivate, WhLocalCoarsePrivate);
            }
        }
        else
            for(int i = level - 1; i > 0; --i)
                meshName[i - 1] = meshName[i];
    }
    if(!removeZeros && (fakeInterface != -111111 || overlap != 1)) {
        if(suppSmooth[].min < 0.501) {
            supp = supp;
            borderName[level - 1] = trunc(globalName, (suppSmooth > (overlap - 0.999) / real(2 * overlap)) && (suppSmooth < 0.501), label = (abs(fakeInterface) + 1) * 100);
            if(s > 1)
                for(int i = level - 2; i >= 0; --i) {
                    borderName[i] = trunc(borderName[i + 1], 1, split = s, label = (abs(fakeInterface) + 1) * 100);
                    meshN tempRefined = meshName[i] + borderName[i];
                    fespace PhRefinedPrivate(tempRefined, P0);
                    PhRefinedPrivate suppRefined = supp;
                    fespace VhBorderRefinedPrivate(borderName[i], P1);
                    VhBorderRefinedPrivate suppBorder = suppRefined;
                    borderName[i] = trunc(borderName[i], suppBorder > 0.01);
                }
            else
                for(int i = level - 2; i >= 0; --i)
                    borderName[i] = borderName[i + 1];
        }
    }
    fespace VhLocalPrivate(meshName[level - 1], P1);
IFMACRO(!privateDmesh#meshName)
NewMacro privateDmesh#meshName#intersectionDef()partitionIntersectionTab EndMacro
    real[int][int] partitionIntersectionTab(1 + intersection[0].n);
    privateDmesh#meshName#intersectionDef[0].resize(intersection[0].n);
ENDIFMACRO
IFMACRO(privateBuildDmesh)
    privateDmesh#meshName#intersectionDef.resize(1 + intersection[0].n);
    privateDmesh#meshName#intersectionDef[0].resize(intersection[0].n);
ENDIFMACRO
    VhLocalPrivate khi = max(2 * suppSmooth - 1.0, 0.0);
    VhLocalPrivate sum;
    sum[] = khi[];
    VhGlobalPrivate phi;
    if(n2oGlobalPrivate.n == globalName.nt && s == 1) {
        real[int] restrictionPart(n2oGlobalPrivate.n);
        restrictionPart = part[](n2oGlobalPrivate);
        part = 0.0;
        part[] = restrictionPart;
    }
    else
        part = part;
    n2oGlobalPrivate.resize(0);
    int numberIntersection = 0;
    {
        int[int] restriction = restrict(VhLocalPrivate, VhGlobalPrivate, n2oNeighbor);
        n2oNeighbor.resize(0);
        /* mpiWaitAll(rq); */
        
        for(int debugI = 0; debugI < 2*intersection[0].n; ++debugI) mpiWaitAny(rq);
        for(int debugI = 0; debugI < intersection[0].n; ++debugI) epsTab[debugI] = 1.0;
        
        
        for(int i = 0; i < intersection[0].n; ++i) {
            PhGlobalPrivate suppPartition = abs(part - intersection[0][i]) < 0.1;
            AddLayers(globalName, suppPartition[], overlap, phi[]);
            if(min(eps, epsTab[i]) > 0.0) {
                if(intN(globalName, qforder = 2)(phi) / min(eps, epsTab[i]) > 1.0e-10) {
                    privateDmesh#meshName#intersectionDef[1 + numberIntersection].resize(restriction.n);
                    privateDmesh#meshName#intersectionDef[1 + numberIntersection] = phi[](restriction);
                    if(!trueRestrict)
                        sum[] += privateDmesh#meshName#intersectionDef[1 + numberIntersection];
                    intersection[0][numberIntersection++] = intersection[0][i];
                }
            }
        }
    }
    if(numberIntersection != intersection[0].n) {
        intersection[0].resize(numberIntersection);
        privateDmesh#meshName#intersectionDef.resize(1 + numberIntersection);
    }
    intersection.resize(1 + level * numberIntersection);
ENDIFMACRO
IFMACRO(privateCreateMat)
    assert(level == 1);
    int numberIntersection = privateDmesh#meshName#intersectionDef.n - 1;
    intersection.resize(1 + level * numberIntersection);
    intersection[0].resize(numberIntersection);
    fespace VhLocalPrivate(meshName[level - 1], P1);
    for[i, v : privateDmesh#meshName#intersectionDef[0]] intersection[0][i] = v;
IFMACRO(privateDmesh#N2O)
IFMACRO(privateDmesh#Original)
IFMACRO(privateDmesh#Restriction)
    {
        fespace WhLocalPrivate(meshName[level - 1], P);
        fespace WhOriginalPrivate(privateDmesh#Original, P);
        privateDmesh#Restriction.resize(WhOriginalPrivate.ndof);
        privateDmesh#Restriction = restrict(WhLocalPrivate, WhOriginalPrivate, privateDmesh#N2O);
    }
ENDIFMACRO
ENDIFMACRO
ENDIFMACRO
ENDIFMACRO
IFMACRO(privateBuildDmesh)
    privateDmesh#meshName#intersectionDef[0].resize(numberIntersection);
    for[i, v : intersection[0]] privateDmesh#meshName#intersectionDef[0][i] = v;
ENDIFMACRO
    meshN[int] meshIntersection(numberIntersection);
    for(int j = 0; j < (s == 1 ? 1 : level); ++j) {
        for(int i = 0; i < numberIntersection; ++i) {
            int[int] n2o;
            VhLocalPrivate partitionIntersection;
            partitionIntersection[] = privateDmesh#meshName#intersectionDef[1 + i];
            meshIntersection[i] = trunc(meshName[j], partitionIntersection > 1.0e-6, new2old = n2o, label = 9999);
IFMACRO(privateDmesh#CartesianPartitioning)
            real[int] bb(2 * dimension);
            boundingbox(meshIntersection[i], bb);
            meshIntersection[i] = trunc(meshName[j], x > bb[0] && x < bb[1] && y > bb[2] && y < bb[3]
IFMACRO(dimension,3)
                                                                                                      && z > bb[4] && z < bb[5]
ENDIFMACRO
                                                                                                                               , new2old = n2o, label = 9999);
ENDIFMACRO
IFMACRO(!privateCreateMat)
            if(!removeZeros)
ENDIFMACRO
            {
IFMACRO(vectorialfe)
                fespace singleComponentWhPrivate(meshName[j], vectorialfe);
                fespace WhIntersectionPrivate(meshIntersection[i], vectorialfe);
ENDIFMACRO
IFMACRO(!vectorialfe)
                fespace singleComponentWhPrivate(meshName[j], P);
                fespace WhIntersectionPrivate(meshIntersection[i], P);
ENDIFMACRO
                intersection[1 + i + j * numberIntersection] = restrict(WhIntersectionPrivate, singleComponentWhPrivate, n2o);
            }
        }
    }
IFMACRO(!privateCreateMat)
    if(s == 1 && level > 1 && !removeZeros)
        for(int j = 1; j < level; ++j)
            for(int i = 0; i < numberIntersection; ++i) {
                intersection[1 + i + j * numberIntersection].resize(intersection[1 + i].n);
                intersection[1 + i + j * numberIntersection] = intersection[1 + i];
            }
    for(int i = 0; i < (trueRestrict ? level : level - 1); ++i) {
        fespace VhRefinedPrivate(meshName[i], P1);
        fespace PhRefinedPrivate(meshName[i], P0);
        PhRefinedPrivate partRefined = part;
        PhRefinedPrivate supp = abs(partRefined - rank) < 0.1;
        varf vSupp(u, v) = intN(meshName[i], qforder = 1)(supp * v);
        VhRefinedPrivate khiL;
        khiL[] = vSupp(0, VhRefinedPrivate);
        khiL = khiL > 0.0;
        VhRefinedPrivate sum = khiL;
        for(int j = 0; j < numberIntersection; ++j) {
            supp = abs(partRefined - intersection[0][j]) < 0.1;
            VhRefinedPrivate phiL;
            phiL[] = vSupp(0, VhRefinedPrivate);
            phiL = phiL > 0.0;
            sum[] += phiL[];
        }
        khiL[] ./= sum[];
        if(i < level - 1) {
            fespace WhRefinedPrivate(meshName[i], PkPart);
            WhRefinedPrivate defPart(func2vec);
            defPart(func2vec) = initPart(khiL);
            D[i].resize(WhRefinedPrivate.ndof);
            D[i] = func2vec[];
        }
        else
            khi[] = khiL[];
    }
    if(!trueRestrict)
        khi[] ./= sum[];
    if(trueRestrict && mpiSize(comm) == size && removeZeros) {
        assert(level == 1);
        meshN ThIntersection;
        fespace PhIntersectionPrivate(ThIntersection, P0);
        PhIntersectionPrivate[int] recv(numberIntersection);
        PhIntersectionPrivate[int] send(numberIntersection);
        mpiRequest[int] rq(2 * numberIntersection);
        for(int i = 0; i < numberIntersection; ++i) {
            ThIntersection = meshIntersection[i];
            Irecv(processor(intersection[0][i], comm, rq[i]), recv[i][]);
            send[i] = khi;
            Isend(processor(intersection[0][i], comm, rq[numberIntersection + i]), send[i][]);
        }
        meshName[0] = trunc(meshName[0], khi > 1.0e-6, label = 9999);
        khi = khi;
        int[int] skip(0);
        for(int k = 0; k < 2 * numberIntersection; ++k) {
            int i = mpiWaitAny(rq);
            if(i < numberIntersection) {
                ThIntersection = meshIntersection[i];
                PhIntersectionPrivate intersection = send[i] > 1.0e-6 && recv[i] > 1.0e-6;
                if(intersection[].l2 > 1.0e-6)
                    meshIntersection[i] = trunc(meshIntersection[i], intersection  > 1.0e-6, label = 9999);
                else {
                    skip.resize(skip.n + 1);
                    skip[skip.n - 1] = i;
                }
            }
        }
        skip.sort;
        intersection.resize(1 + numberIntersection - skip.n);
        int j = 0;
        for(int i = 0; i < numberIntersection; ++i) {
            bool skipped = false;
            if(j < skip.n) {
                if(skip[j] == i) {
                    ++j;
                    skipped = true;
                }
            }
            if(!skipped) {
IFMACRO(vectorialfe)
                fespace singleComponentWhPrivate(meshName[0], vectorialfe);
                fespace WhIntersectionPrivate(meshIntersection[i], vectorialfe);
ENDIFMACRO
IFMACRO(!vectorialfe)
                fespace singleComponentWhPrivate(meshName[0], P);
                fespace WhIntersectionPrivate(meshIntersection[i], P);
ENDIFMACRO
                matrix meshName#R = interpolate(WhIntersectionPrivate, singleComponentWhPrivate);
                meshName#R.thresholding(1.0e-10);
                real[int] meshName#C;
                int[int] meshName#I;
                [meshName#I, intersection[1 + i - j], meshName#C] = meshName#R;
                intersection[1 + i - j].resize(meshName#R.nbcoef);
                intersection[0][i - j] = intersection[0][i];
            }
        }
        numberIntersection -= skip.n;
        intersection[0].resize(numberIntersection);
        if(fakeInterface != -111111 || overlap != 1) {
            PhGlobalPrivate suppPartition = khi > 0.1;
            AddLayers(globalName, suppPartition[], 1, phi[]);
            borderName[0] = trunc(globalName, phi > 0.001 && phi < 0.501, label = (abs(fakeInterface) + 1) * 100);
        }
    }
ENDIFMACRO
IFMACRO(vectorialfe)
    if(bs > 1)
        for(int i = 0; i < intersection.n - 1; ++i) {
            int n = intersection[1 + i].n;
            intersection[1 + i].resize(n * bs);
            for(int j = n - 1; j != -1; --j)
                for(int k = bs - 1; k != -1; --k)
                    intersection[1 + i][j * bs + k] = intersection[1 + i][j] * bs + k;
        }
ENDIFMACRO
ENDIFMACRO
IFMACRO(privateCreatePartition)
    fespace VhLocalPrivate(meshName[level - 1], P1);
IFMACRO(!privateCreateMat)
    VhLocalPrivate khi;
ENDIFMACRO
ENDIFMACRO
IFMACRO(privateCreateMat)
    VhLocalPrivate khi;
    khi[] = privateDmesh#meshName#khiDef[0];
ENDIFMACRO
    fespace WhPartPrivate(meshName[level - 1], PkPart);
    WhPartPrivate defPart(func2vec);
    D[level - 1].resize(WhPartPrivate.ndof);
    if((WhPartPrivate.ndof % meshName[level - 1].nt) == 0) {
        int constant = rank;
IFMACRO(privateCreateMat)
        fespace PhLocalPrivate(meshName[level - 1], P0);
        PhLocalPrivate partLocal;
        partLocal[] = privateDmesh#meshName#khiDef[1];
        defPart(func2vec) = initPart(abs(partLocal - constant) < 0.1);
ENDIFMACRO
IFMACRO(!privateCreateMat)
        defPart(func2vec) = initPart(abs(part - constant) < 0.1);
ENDIFMACRO
    }
    else if(WhPartPrivate.ndof == meshName[level - 1].nv) {
        func2vec[] = khi[];
    }
    else {
        defPart(func2vec) = initPart(khi);
    }
    D[level - 1] = func2vec[];
IFMACRO(!privateCreatePartition)
IFMACRO(!privateCreateMat)
IFMACRO(privateBuildDmesh)
    fespace PhLocalPrivate(meshName[level - 1], P0);
    PhLocalPrivate partLocal;
    partLocal = part;
    privateDmesh#meshName#khiDef[1].resize(partLocal[].n);
    privateDmesh#meshName#khiDef[1] = partLocal[];
ENDIFMACRO
ENDIFMACRO
ENDIFMACRO
    searchMethod = backupSM;
}// EOM
