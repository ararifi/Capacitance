// ------ READ-ME ------
/*
-> BEACHTE: hier wird keine Untescheidung zwischen Droplet und Ice gemacht.
*/

// -----------------------------------------------------------------------------
// MACROS AND FUNDAMENTALS
// -----------------------------------------------------------------------------   
    
// init seed of rng
randinit(0);

// macro for periodic boundary along one axis for spheres with radius r
macro div(n, d) int((n)/(d)) //

// axis periodic boundary
macro apb(axis, ind) axis - 
    sign(axis) * (boxSize-2*R[ind]) * div(sign(axis) * axis + boxSize/2.0 - R[ind], boxSize-2*R[ind]) //

macro isSetMPI(arg)if(arg==0){mpiBarrier(mpiCommWorld); exit(-1);} //

macro collapse()
    {
        int oldNumMeteor = numMeteor;

        numMeteor = Commit.sum;

        /* copy and trancuate */
        real[int] CpR = R, CpPos = Pos;
        R.resize(numMeteor); Pos.resize(3 * numMeteor);
        
        /* swap commited positions */
        int cnt = 0;
        for [ind, commit : Commit]{
            if( commit == 1 ){ 
                R[cnt] = CpR[ind];
                Pos(3*cnt : 3*(cnt+1)-1) = CpPos(3*ind : 3*(ind+1)-1);
                cnt++;
            }
            IFMACRO(SPECTRUE, TRUE)
            else{
                if( cnt < numDroplet ){ numDroplet -= 1; } 
                else{ numIce -= 1; }
            }
            ENDIFMACRO
        } 
        Commit.resize(numMeteor); Commit = 1;
    
        cout << "collapse done \n" << (oldNumMeteor - numMeteor) << " Meteor(s) removed" << endl;    
    }
//

IFMACRO(SPECTRUE, TRUE)
macro checkLength(ind, num)
    if(ind < numDroplet - 1){
        if(num > numDroplet+ind){cout << "too many particles for Droplets at index ind" << endl;}
    }else{
        if(num > numIce+ind){cout << "too many particles for Ice at index ind" << endl;}
    }
//
ENDIFMACRO

// -----------------------------------------------------------------------------
// SPATIAL MANIPULATION GENERAL
// -----------------------------------------------------------------------------

func bool commitIt(int ind){Commit[ind]=1; return true;}

func bool uncommitIt(int ind){Commit[ind]=0; return true;}

func int[int] isOK(int ind1){    
    /* considered for the setting */
    int[int] status(3);
    bool check = true;

    real[int] dist(3), newPos(3);
    newPos = Pos(3*ind1 : 3*ind1 + 2);  
    real dist2; 
    for(int ind2 = 0; ind2 < Pos.n/3; ind2++){
        status[1] = ind1; status[2] = ind2;
        // if same index OR the position of the particle
        // @ ind2 is not set continue
        if(ind2 == ind1 || Commit[ind2] != 1){continue;}
     //   dist[0] = Pos[3*ind2] - Pos[0];
     //   dist[1] = Pos[3*ind2+1] - Pos[1];
     //   dist[2] = Pos[3*ind2+2] - Pos[2];
        dist = Pos(3*ind2 : 3*ind2 + 2) - newPos;
        dist2 = dist'*dist;
        if(dist2 <= (R[ind1] + R[ind2])^2){status[0] = 0; return status;}
    }
    status[0] = 1; return status;
}

func bool setPos(int ind, real[int] newPos, bool veb){
    {
        Pos[3*ind] = apb(newPos[0], ind);
        Pos[3*ind + 1] = apb(newPos[1], ind);
        Pos[3*ind + 2] = apb(newPos[2], ind);
    }    
    int[int] status = isOK(ind);
    if(status[0]==1){
        // set the Commit array
        commitIt(ind); 
        return true;
    }
    if(veb){cout << "collison! of particle " + status[1] + " with " + status[2] + " cannot set position" << endl;}
    return false;   
}

func bool forceSetPos(int ind, real[int] newPos){
    {
        Pos[3*ind] = apb(newPos[0], ind);
        Pos[3*ind + 1] = apb(newPos[1], ind);
        Pos[3*ind + 2] = apb(newPos[2], ind);
    }    
    int[int] status = isOK(ind);
    bool isCol = !(status[0]==1); 
    while(isCol){
        uncommitIt(status[2]);
        status = isOK(ind); 
        isCol = !(status[0]==1);
    }  
    commitIt(ind); return true;
} 


// -----------------------------------------------------------------------------
// SPATIAL MANIPULATION SPECIFIC
// -----------------------------------------------------------------------------

// distribute the particles evenly on a sphere by radius "r"
// here we use the thomson problem
// https://www-wales.ch.cam.ac.uk/~wales/CCD/Thomson/table.html
// Structure and Dynamics of Spherical Crystals Characterised for the Thomson Problem, 
// Phys. Rev. B, 74, 212101 (2006).
func bool thomsonSphere(int offsetInd, int num, real[int] &  Mid, real r){

    IFMACRO(SPECTRUE, TRUE)
    // check the length of the given range
    checkLength(offsetInd, num)
    ENDIFMACRO

    // load the thomson sphere
    real[int] arr(3*num);
    try{
        ifstream io("../../../ffpkg/pkgMesh/ThomsonFreeFem_xyz/"+string(num)+".xyz");
        
        // load io into array
        io >> arr;
    }catch(...){
        cout << "thomson sphere: invalid number of particles" << endl;
        return false;
    }
    
    // set the particles    
    real[int] temp(3);
    for(int ind = 0; ind < num; ind++){
        temp = r * arr(3*ind:(3*ind + 2)) + Mid;
        if(!setPos(offsetInd + ind, temp, true)){return false;}
    }

    return true;
}

// only until 6 particles allowed
func bool lessSphere(int offsetInd, int num, real[int] &  Mid, real r){
    
    IFMACRO(SPECTRUE, TRUE)
    // check the length of the given range
    checkLength(offsetInd, num)
    ENDIFMACRO

    real[int] SPHERE6 = [
        1, 0, 0, 
        -1, 0, 0, 
        0, 1, 0, 
        0 -1, 0, 
        0, 0, 1,
        0, 0, -1
        ];

    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
    // set the particles
    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-    
    
    real[int] Temp(3), Coord(3);
    for(int ind = 0; ind < num; ind++){
        Coord[0] = SPHERE6[3 * ind];
        Coord[1] = SPHERE6[3 * ind + 1];
        Coord[2] = SPHERE6[3 * ind + 2];

        Temp = r * Coord + Mid;
        if(!setPos(offsetInd + ind, Temp, true)){return false;}
    }
    return true;
    

}

// FOR NUMBERS BIGGER EQUAL THAN 12
func bool isoSphere(int offsetInd, int num, real[int] &  Mid, real r){
    IFMACRO(SPECTRUE, TRUE)
    // check the length of the given range
    checkLength(offsetInd, num)
    ENDIFMACRO

    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
    // load the iso sphere
    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-    
    
    // get the av numbers
    int numElem = exec("num=\"$( ls "+meshSPATH+"*.nv | grep -Po \"\\d*(?=\.nv)\" )\"; exit ${num}")/256;
    exec("cd "+meshSPATH+"; ls");
    ifstream ifs(meshSPATH+numElem+".nv");
    real[int] arr(numElem); 
    for [i, elem : arr]{ifs >> elem;}

    // select a sphere
    int minInd = 0;
    while(arr[minInd] < num && minInd < (arr.n-1)){minInd += 1;}

    // read mesh
    meshS ThS = readmeshS(meshSPATH+string(minInd+1)+".mesh");

    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
    // set the particles
    // -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-    
    
    real[int] Temp(3), Coord(3);
    for(int ind = 0; ind < num; ind++){
        Coord[0] = ThS(ind).x;
        Coord[1] = ThS(ind).y;
        Coord[2] = ThS(ind).z;

        Temp = r * Coord + Mid;
        if(!setPos(offsetInd + ind, Temp, true)){return false;}
    }
    return true;
}

func bool setRandom(int ind, int dist, real pSphereSize){  
    /*
        IMPLEMENTED DISTRIBUTION FUNCTION 
        (1) UNIFORM DISTRIBUTION
    */
    
    // default values for rndSphereSize
    real rndSphereSize = pSphereSize;
    if(rndSphereSize == 0){rndSphereSize = boxSize;}

    // measure the time
    real cpu=clock();

    // set state variable
    bool state = false;

    real[int] temp(3);
    
    // the random variable
    real rnd;
    while(!state){
        real tempR2 = 3 * rndSphereSize^2; 
        while(tempR2 > rndSphereSize^2){
            for [i, elem : temp]{
                
                // set the distribution
                if(dist == 1){
                    rnd = rndSphereSize * (2*randreal2()-1);
                }            
                // std is uniform distribution: rnd = SphereSize * (2*randreal2()-1);
                elem = apb(rnd, ind);
            }
            tempR2 = temp'*temp;
        }
        state = setPos(ind, temp, false);
        
        if ((clock()-cpu) > 60){
            cout << "timeout (60s)" << endl; return false;
        }        
    }
    return state;   
}

func bool setGrid(int offsetInd, int num, real[int] & Mid, real sizeLBox){
    
    // if only one particle set Mid Point as Position
    if(num == 1){return setPos(offsetInd, Mid, true);}

    IFMACRO(SPECTRUE, TRUE)
    // check the length of the given range
    checkLength(offsetInd, num)
    ENDIFMACRO
    
    // create the array for the grid
    real[int] a(3*num);

    // get the dimension of lattice box
    int dimLBox = int(ceil(num^(1.0/3.0)));

    // get equidistant distances of the particles
    real eqSize = sizeLBox / (dimLBox - 1);

    // set the offset of the particles, such that the mid point of the
    // grid is at the @ center 
    real[int] offset(3); offset = - eqSize  * ( floor(dimLBox/2.0) - ((dimLBox+1) % 2)/2.0  );
    // * ((round(dimLBox/2)-1) + ((dimLBox+1) % 2)/2.0); 
    
    offset = offset + Mid; 
    // set the particles
    real[int] temp(3);
    for(int ind = 0; ind < num; ind++){
        temp[0] = eqSize * (ind % dimLBox) + offset[0];
        temp[1] = eqSize * (div(ind, dimLBox) % dimLBox) + offset[1];
        temp[2] = eqSize * (div(ind, dimLBox * dimLBox) % dimLBox) + offset[2];
        if(!setPos(offsetInd + ind, temp, true)){return false;}
    }

    return true;
}

// -----------------------------------------------------------------------------
// ARRAY MANIPULATION
// -----------------------------------------------------------------------------

func bool setAC(real[int] & AC, real setA, real setC){
    if(AC.n%2!=0){
        return false;
    }else{
        for(int i = 0; i < AC.n/2; i++){
            AC(2*i) = setA; AC(2*i + 1) = setC; 
        }
        return true;
    }
}

func real[int] createArr(int n, real val){real[int] Arr(n); Arr = val; return Arr;}

// -----------------------------------------------------------------------------
// SCALING FUNCTIONS
// -----------------------------------------------------------------------------

IFMACRO(SPECTRUE, FALSE)
// jumpsize of scaling
func real scJump(int jumpInd){return jumpInd * int(currInd / jumpInd);}

// scaling of unity
func real sc1(int jumpInd, real phase){
    if(!simMaxInd){
        return 0;
    }else{
        return (scJump(jumpInd) + phase) / (simMaxInd-1);
    }
}
 
// scaling of cosinus
func real scCos(int jumpInd, real phase){return cos(2 * pi * sc1(jumpInd, phase));}

// scaling of sinus
func real scSin(int jumpInd, real phase){return sin(2 * pi * sc1(jumpInd, phase));}

// jumpInd for simultanous scaling in r and phi direction, number of rotation 
// is proportional to the distance to the center
func int scJumpIndShiftRot(){
    // first evaluate number of spheres at given simMaxInd
    int numShell = 0; 
    int cnt;
    while(cnt < simMaxInd){
        cnt = 0;
        for(int i = 0; i < numShell; i++){
            cnt += int(floor(numShell/(i + 1)));
        }
        numShell ++;
    }
    // get shell ind corresponding to simInd and return the number of points
    // on the corresponding shell for the jumpInd
    int sumInd = 0, shellInd = 0;
    int numPointShell = 0;
    while(sumInd < simInd){
        numPointShell = int(floor(numShell/(shellInd + 1)));
        sumInd += numPointShell; 
        shellInd ++;
    }
    return numPointShell;
}   

ENDIFMACRO
// -----------------------------------------------------------------------------