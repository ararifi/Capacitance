// MODIFIED FROM
// https://github.com/FreeFem/FreeFem-sources/blob/master/examples/hpddm/helmholtz-3d-surf-PETSc-complex.edp

/*
NOTE:
FOR MORE METEORS ONLY ON ONE PROCESS POSSIBLE TO ACHIEVE PARALLELISM 
ONE CAN DO THE FOLLOWING THING
-> DISTRIBUTE THE WORK OF ASSEMBLING EQUALLY
-> SEND THE MATRICES TO THE CORRESPONDING RANKS
-> ASSEMBLE WITH PETSC WITH: 
https://github.com/FreeFem/FreeFem-sources/blob/master/examples/hpddm/block-PETSc.edp
-> EVAL SOLUTION 
*/


//-------------------------------------------------------
// LOAD & INCLUDES
//-------------------------------------------------------

// --- FreeFEM ---
load "bem"
load "msh3"
load "iovtk"
load "PETSc-complex"
include "MeshSurface.idp"
macro dimension()3S//
include "macro_ddm2.idp"

// --- USER DEFINED ---
include "configRun.edp"
include "pkgMesh/mesh_surface.idp"
include "bMacro.idp"
include "pkgMesh/mesh_macro.idp"
include "macro.idp"




// -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
// FUNDAMENTAL SETTINGS
//
// -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-

// ----- LAPLACIAN PROBLEM -----
complex k = 0;

// ----- INIT VECTOR TO STORE SOL -----
int numElem = 0;
for(int i = 0; i < numMeteor; i++){numElem += (i + 1);}
real[int] Cap(numElem), CapG(numElem);

real[int] EffCap(3);

// not needed here, but needed for compatibility
real[int] NormArea(numMeteor);

// array for storing the elapsed time
real[int] Elapsed(2), ElapsedMsh(1);

// -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
// (0) MESH
//
// init mesh

real timeMesh = clock();

// -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-


// construct meteor meshes in parallel
meshS ThS = readmeshS(meshPath);

//initMeteorMesh
//{
//    setMeteorMeshMPI0
//}
mpiBarrier(Comm);

if(MPIRank == 0){cout << "INFO: meshS loaded " << endl;}

// define a variable to store the global mesh along all processes
meshS ThG; ThG = ThS;


// -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
// (1) ASSEMBLE
//

real timeAssemble = clock(); 
ElapsedMsh[0] = timeAssemble - timeMesh;

// assemble H-Matrix for BEM to solve the Dirichlet problem and 
// double transpose layer to get the gauss integral
// -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-

// ----- FESPACES -----

// define FE-Spaces (local, global)
fespace Uh(ThS, P1);
fespace UhG(ThG, P1);

// define H-Matrix (approx. discretized Green function)
Mat<complex> H, HPot;

int[int] n2o;
{   
    // get the indices due to the partitioning
    macro ThSN2O()n2o//
    createMat(ThS, H, P1);

    createMat(ThS, HPot, P1);
    Mat<complex> T;
    createMat(ThS, T, P0);
    // renumber global mesh in order to use BEM with PETSC
    CoherentGlobalMesh(T, H, ThS, ThG);
}

// ----- SL TO SOLVE -----

/* SINGLE-LAYER for Dirichlet Problem */
varf SL(u, v) = int2dx2d(ThG)(ThG)(BEM(BemKernel("SL", k=k), u, v));

if(MPIRank == 0){cout << "INFO: construct single layer... " << endl;}

/* assemble matrix */
H = SL(UhG, UhG, sparams = "-mat_htool_epsilon 1.0e-6 -ksp_rtol "+ string(solverEps));

if(MPIRank == 0){cout << "INFO: single layer constructed " << endl;}

// ----- TDL FOR CAP -----

/* DOUBLE-LAYER for integral */
varf TDL(u, v) = int2dx2d(ThG)(ThG)(BEM(BemKernel("TDL", k=k), u, v));

if(MPIRank == 0){cout << "INFO: construct transposed double layer..." << endl;}

/* assemble matrix for reconstruction (maybe restrict UhG) */
HPot = TDL(UhG, UhG, sparams = "-mat_htool_epsilon 1.0e-6");

if(MPIRank == 0){cout << "INFO: transposed double layer constructed " << endl;}

/* for right hand side */

/* solution vector */
Uh<complex> CAP; Uh CAPreal;



// -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
// (1) ITERATE
//
// Iterate through all configuations, solve problem and get the integral

real timeEval = clock();
Elapsed[0] = timeEval - timeAssemble;

// -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-

int offsetInd = 0;
for(int ind1 = 0; ind1 < numMeteor; ind1++){
    Uh<complex> RHS; Uh FILTER2;

    // ----- SET RIGHT HAND SIDE -----
            
    varf vBOUNDARY(unused, v) = on(ind1 + 7, unused = 1); 
    UhG BOUNDARY; BOUNDARY[] = vBOUNDARY(0, UhG, tgv=-1);  

    varf vRHS(unused, v) = int2d(ThS)(BOUNDARY * v);

    RHS[] = vRHS(0, Uh);

    // ---- SOLVE PROBLEM ON SURFACE -----
    complex[int] p = H^-1 * RHS[];
    
    // ---- GET CAP -----
    CAP[] = HPot*p;

    CAPreal = real(CAP);
    
    CAPreal[] .*= HPot.D;

    // ---- GET CAP FOR EACH SPHERE -----
    

    /* store solution of capacity coefficient only for one sphere*/

    for(int ind2 = ind1; ind2 < numMeteor; ind2++){
        varf vFILTER(unused, v) = on(ind2 + 7, unused = 1);
        
        real[int] FILTER = vFILTER(0, Uh, tgv=-1);
                
        Cap[offsetInd] = 1/(2*pi) * ( FILTER'*CAPreal[] );

        offsetInd++;

        if(MPIRank == 0){cout << "INFO: capacity coefficient " + ind1 + ind2 + " calculated" << endl;}   
	}

    mpiBarrier(Comm);
            
}


// -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
// (4) RECORD
//
//  store the values needed for the later analysis

Elapsed[1] = clock() - timeEval;

// -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-


// reduce local solution

mpiBarrier(Comm);
mpiAllReduce(Cap, CapG, Comm, mpiSUM);
Cap = CapG;


// save all results
if(MPIRank==0){

    // C11
    EffCap[0] = Cap[mainMeteorInd];

    // C12
    for(int ind1 = 0; ind1 < numMeteor; ind1++){
        if(ind1 == mainMeteorInd){continue;}
        EffCap[1] += Cap[ind1];
    }


    // C22
    int offset = 0;
    for(int ind1 = 0; ind1 < numMeteor; ind1++){
        for( int ind2 = 0; ind2 < numMeteor-ind1; ind2++){
            if(ind1 == 0){continue;}
            EffCap[2] += Cap[ind2+offset];
        }
        offset += numMeteor - ind1;
    }    

    record
}
mpiBarrier(Comm);