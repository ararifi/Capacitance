//-------------------------------------------------------
// LOAD & INCLUDES
//-------------------------------------------------------

// --- FreeFEM ---
/*load "msh3"*/
load "tetgen2"
/*load "medit"*/
load "PETSc"
load "iovtk"
include "MeshSurface.idp"
macro dimension()3//
macro partitioner()parmetis//
include "macro_ddm2.idp"

// --- USER DEFINED ---
include "configRun.edp"
include "pkgMesh/mesh_surface.idp"
include "bMacro.idp"
include "macro.idp"

// ----- FINITE ELEMENT SPACE -----
func Pk = P2;

// ----- QUADRATURE FORMULAR -----
macro QFV()qfV5//
macro DQFV()qfV2//
macro QFT()qf2pT//

// -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
// (0) MESH + TIME
//
// init mesh
// -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-

// read mesh
mesh3 ThNo, Th = readmesh3(meshPath);
mpiBarrier(Comm);

fespace Ph(Th, P0);
Ph part;

// distribute overlapped mesh to the other processeors
buildDmesh(Th)
mpiBarrier(Comm);

createPartition(Th, part[], P0)
mpiBarrier(Comm);


int[int] n2o;
ThNo = trunc(Th, abs(part - 1.0) < 1e-1, new2old = n2o);

// evaluate goodness of sphere surfaces
real[int] NormArea(numMeteor);

real localNormArea, globalNormArea;
if(MPIRank == 0){cout << "INFO: eval goodness of the sphere surfaces" << endl;}
for(int ind = 0; ind < numMeteor; ind++){
        getLocalNormArea(ind + 7) 
        sumMPI(localNormArea, globalNormArea)
        NormArea[ind] = globalNormArea;
}

real[int] Elapsed(3);

// -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
// (1) INIT
//
// init the fespace for the field and the matrix for the
// capacity coefficients
// -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-

fespace Vh(Th, Pk);
int dofVh = Vh.ndof;

// ----- FIELD -----

Vh uh, bh;

// ----- INIT -----

int numElem = 0;
for(int i = 0; i < numMeteor; i++){numElem += (i + 1);}
real[int] Cap(numElem);

real[int] EffCap(3);

// -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
// (2) ASSEMBLING
//  
//  assemble a dirchlet data free stiffness matrix, see
//  https://community.freefem.org/t/exact-dirichlet-bc/52/3

real timeAssemble = clock();

// -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-


// assemble the stiffness matrix
Mat A(dofVh); 
{
    varf a(u, v) = H1(u, v) + deltaUZero(u);


    createMat(Th, A, Pk)
    if(MPIRank==0){cout << "INFO: fill stiffness matrix "<< endl;} 
    A = a(Vh, Vh, tgv = -2);

    set(A, sparams = "-pc_type hpddm -ksp_type gmres -ksp_rtol "+ string(solverEps));
}

// assemble rhs
real[int] Rhs(dofVh);


// -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
// (3) ITERATE
//
//  iterate through all meteors to obtain the capacity coeffcients 

real timeEval = clock();
Elapsed[0] = timeEval - timeAssemble;

// -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-

int offsetInd = 0;
for(int ind1 = 0; ind1 < numMeteor; ind1++){
    
    // assembling special case and solve
    {
        // set none zero dirchlet condition
        varf bndDirichlet(unused, v) = on(ind1 + 7, unused = 1);

        bh[] = bndDirichlet(0, Vh, tgv = -1);

        varf l(unused, v) = -H1(bh, v) + deltaUZero(unused);

        // set rhs
        Rhs = l(0, Vh);
        
        // solve the problem

        if(MPIRank == 0){cout << "INFO: solve problem for index " + ind1 << endl;}
        uh[] = A^-1 * Rhs;

        // add boundary values to solution
        uh[] += bh[];
    }

    // evaluate the capacity coefficient
    real localCap, globalCap;
    if(MPIRank == 0){cout << "INFO: eval capacity coefficient for index " + ind1 << endl;}
	for(int ind2 = 0; ind2 <= ind1; ind2++){
            getLocalCap(ind2 + 7) 
            sumMPI(localCap, globalCap)
            Cap[offsetInd] = globalCap;
            offsetInd++;
	}
}


// -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
// (4) EVAL EFFECTIVE CAPACITY COEFFICIENT
//

real timeEval2 = clock();
Elapsed[1] = timeEval2 - timeEval;

// -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-

    if(MPIRank == 0){cout << "INFO: eval effective capacity coefficient for index " + mainMeteorInd << endl;}
// C11
{
    if(MPIRank == 0){cout << "INFO: eval effective C11" << endl;}
    
    /* index of symmetric matrix formatted in a plain array */
    int diagonalMainMeteorInd = ((mainMeteorInd + 1) * mainMeteorInd) / 2 + mainMeteorInd;
    EffCap[0] = Cap[diagonalMainMeteorInd];
}

// C12 & C22
{
    // set none zero dirchlet condition
    varf bndDirichlet(unused, v) = deltaUZero(unused) + deltaUOneMeteor(unused) + on(mainMeteorInd + 7, unused = 0);

    bh[] = bndDirichlet(0, Vh, tgv = -1);

    varf l(unused, v) = -H1(bh, v) + deltaUZero(unused);

    // set rhs
    Rhs = l(0, Vh);
    
    // solve the problem

    if(MPIRank == 0){cout << "INFO: solve problem for effective C12 and C22" << endl;}
    uh[] = A^-1 * Rhs;

    // add boundary values to solution
    uh[] += bh[];
    

    // C12
    {
        if(MPIRank == 0){cout << "INFO: eval effective C12" << endl;}
        real localCap, globalCap;
        getLocalCap(mainMeteorInd + 7)
        sumMPI(localCap, globalCap)
        EffCap[1] = globalCap;
    }
    
    // C22
    {   
        real localCap, globalCap;
        real sumGlobalCap = 0;
        if(MPIRank == 0){cout << "INFO: eval effective C22" << endl;}
        for(int ind1 = 0; ind1 < numMeteor; ind1++){
            if(ind1 == mainMeteorInd){continue;}
            getLocalCap(ind1 + 7) 
            sumMPI(localCap, globalCap)
            sumGlobalCap += globalCap;
        }
        EffCap[2] = sumGlobalCap;
    }

}

// -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
// (5) RECORD
//
//  store the values needed for the later analysis

Elapsed[2] = clock() - timeEval2;

// -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-

if(MPIRank==0){record}