//-------------------------------------------------------
// LOAD & INCLUDES
//-------------------------------------------------------

// --- FreeFEM ---
load "msh3"
load "tetgen2"
load "medit"
load "PETSc"
load "iovtk"
include "MeshSurface.idp"
macro dimension()3//
macro partitioner()parmetis//
include "macro_ddm2.idp"

// --- USER DEFINED ---
include "configRun.edp"
include "pkgMesh/mesh_surface.idp"
include "bMacro.idp"
include "macro.idp"

// ----- FINITE ELEMENT SPACE -----
func Pk = P2;

// ----- QUADRATURE FORMULAR -----
macro QFV()qfV5//
macro DQFV()qfV2//
macro QFT()qf2pT//

// -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
// (0) MESH + TIME
//
// init mesh
// -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-

// read mesh
mesh3 ThNo, Th = readmesh3(meshPath);
mpiBarrier(Comm);

fespace Ph(Th, P0);
Ph part;

// distribute overlapped mesh to the other processeors
buildDmesh(Th)
mpiBarrier(Comm);

createPartition(Th, part[], P0)
mpiBarrier(Comm);

int[int] n2o;
ThNo = trunc(Th, abs(part - 1.0) < 1e-1, new2old = n2o);

// evaluate goodness of sphere surfaces
real[int] NormArea(numMeteor);

real localNormArea, globalNormArea;
if(MPIRank == 0){cout << "INFO: eval goodness of the sphere surfaces" << endl;}
for(int ind = 0; ind < numMeteor; ind++){
        getLocalNormArea(ind + 7) 
        sumMPI(localNormArea, globalNormArea)
        NormArea[ind] = globalNormArea;
}
mpiBarrier(Comm);

real[int] Elapsed(2); real[int] ElapsedSol(2);

// -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
// (1) INIT
//
// init the fespace for the field and the matrix for the
// capacity coefficients
// -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-

fespace Vh(Th, Pk);
int dofVh = Vh.ndof;

// ----- FIELD -----

Vh uh, bh;

// ----- INIT -----

int numElem = 0;
for(int i = 0; i < numMeteor; i++){numElem += (i + 1);}
real[int] Cap(numElem);

real[int] EffCap(3);

// -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
// (2) ASSEMBLING
//  
//  assemble a dirchlet data free stiffness matrix, see
//  https://community.freefem.org/t/exact-dirichlet-bc/52/3

real timeAssemble = clock();

// -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-


// assemble the stiffness matrix
Mat A(dofVh); 
{
    varf a(u, v) = H1(u, v) + deltaUZero(u);

    if( mpirank == 0 ){ recordState }
    mpiBarrier(Comm);
    createMat(Th, A, Pk)
    if( mpirank == 0 ){ recordState }
    mpiBarrier(Comm);

    if(MPIRank==0){cout << "INFO: fill stiffness matrix "<< endl;} 
    A = a(Vh, Vh, tgv = -2);

    set(A, sparams = "-pc_type hpddm -ksp_type gmres -ksp_rtol "+ string(solverEps));
}

// assemble rhs
real[int] Rhs(dofVh);


// -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
// (3) EVAL EFFECTIVE CAPACITY COEFFICIENT
//

if(MPIRank == 0){cout << "INFO: eval effective capacity coefficient for index " + mainMeteorInd << endl;}
real timeEval = clock();
Elapsed[0] = timeEval - timeAssemble;

// -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-

// C11
{    
    ElapsedSol[0] -= clock();

    // set none zero dirchlet condition
    varf bndDirichlet(unused, v) = deltaUZero(unused) + on(mainMeteorInd + 7, unused = 1);

    bh[] = bndDirichlet(0, Vh, tgv = -1);

    varf l(unused, v) = -H1(bh, v) + deltaUZero(unused);

    // set rhs
    Rhs = l(0, Vh);
    
    // solve the problem

    if(MPIRank == 0){cout << "INFO: solve problem for effective C11" << endl;}
    uh[] = A^-1 * Rhs;

    // add boundary values to solution
    uh[] += bh[];

    /* index of symmetric matrix formatted in a plain array */

    ElapsedSol[0] += clock();

    // C11
    {
        if(MPIRank == 0){cout << "INFO: eval effective C11" << endl;}
        real localCap, globalCap;
        getLocalCap(mainMeteorInd + 7)
        sumMPI(localCap, globalCap)
        EffCap[0] = globalCap;

        Cap[0] = EffCap[0];
    }

    {
    if(MPIRank == 0){cout << "INFO: eval effective C1n" << endl;}
    // C1n
        real localCap, globalCap;
        for(int ind1 = 0; ind1 < numMeteor; ind1++){
            if(ind1 == mainMeteorInd){continue;}
            getLocalCap(ind1 + 7)
            sumMPI(localCap, globalCap)
            Cap[ind1] = globalCap; // C1n
        }
    }

}


// C12 & C22
if(numMeteor > 1){

    ElapsedSol[1] -= clock();

    // set none zero dirchlet condition
    varf bndDirichlet(unused, v) = deltaUZero(unused) + deltaUOneMeteor(unused) + on(mainMeteorInd + 7, unused = 0);

    bh[] = bndDirichlet(0, Vh, tgv = -1);

    varf l(unused, v) = -H1(bh, v) + deltaUZero(unused);

    // set rhs
    Rhs = l(0, Vh);
    
    // solve the problem

    if(MPIRank == 0){cout << "INFO: solve problem for effective C12 and C22" << endl;}
    uh[] = A^-1 * Rhs;

    // add boundary values to solution
    uh[] += bh[];
    
    ElapsedSol[1] += clock();

    // C12eff
    {
        if(MPIRank == 0){cout << "INFO: eval effective C12" << endl;}
        real localCap, globalCap;
        
        getLocalCap(mainMeteorInd + 7)
        sumMPI(localCap, globalCap)
        EffCap[1] = globalCap;
    }
    
    // C22
    {   
        real localCap, globalCap;
        real sumGlobalCap = 0;
        
        int diagOffset = 1;
        int diagInd = numMeteor;

        if(MPIRank == 0){cout << "INFO: eval effective C22" << endl;}
        for(int ind1 = 0; ind1 < numMeteor; ind1++){
            if(ind1 == mainMeteorInd){continue;}
            getLocalCap(ind1 + 7) 
            sumMPI(localCap, globalCap)
            sumGlobalCap += globalCap;
            
            Cap[diagInd] = globalCap; // C22

            diagInd += numMeteor - diagOffset;
            diagOffset++;

        }
        EffCap[2] = sumGlobalCap;
    }

}

// -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-
// (4) RECORD
//
//  store the values needed for the later analysis

Elapsed[1] = clock() - timeEval;

// -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-

if(MPIRank==0){ record }
