// -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
// HELPER-MACROS 
// -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.

// Normal-Vector of Sphere
macro Normal() [N.x, N.y, N.z]//

// 3D-Gradient
macro Grad(u) [dx(u), dy(u), dz(u)]//

// H0-Norm
macro H0(u, v, Th) int3d(Th, qfV=QFV)(u*v)//

// H1-Norm
macro H1(u, v, Th) int3d(Th, qfV=DQFV)(dx(u)*dx(v) + dy(u)*dy(v) + dz(u)*dz(v))//

macro INFO(msg) if(mpirank == 0){ cout << "INFO: "; cout << msg << endl; }//

// chunk index
macro INDC(ind) Vh.ndof * ind : (Vh.ndof * (ind+1) - 1)//

//-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
// DOMAIN DECOMPOSITION
//-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.

macro myDDM()
if(mpisize > 1) {
    fespace Wh(Th, Pk);
    fespace Ph(Th, P0);
    Ph part;
    mesh3 ThExtended = Th;
    {
        partitionerSeq(part[], Th, mpisize);
        fespace PhExtended(ThExtended, P0);
        PhExtended partExtended;
        partExtended = part;
        for(int i = 0; i < mpisize; ++i) {
            mesh3 ThLocal = trunc(Th, abs(part - i) < 1e-6 && (y > 1-x-Th.hmax || y < -1-x+Th.hmax || y > 1+x-Th.hmax || y < -1+x+Th.hmax), label = 0);
            int j = 0;
            varf vOn(u, v) = on(labPeriodic[j], u = 1);
            fespace Vh(ThLocal, P1);
            Vh u;
            int[int] touch(4);
            touch = 0;
            for(j = 0; j < labPeriodic.n; ++j) {
                u[] = vOn(0, Vh);
                mesh3 ThLocalMoved;
                if(u[].linfty > 1e-12) {
                    if(j == 0) {
                        ThLocalMoved = movemesh(ThLocal, [x + 1, y - 1]);
                        touch[0] = 1;
                    }
                    else if(j == 1) {
                        ThLocalMoved = movemesh(ThLocal, [x - 1, y + 1]);
                        touch[1] = 1;
                    }
                    else if(j == 2) {
                        ThLocalMoved = movemesh(ThLocal, [x - 1, y - 1]);
                        touch[2] = 1;
                    }
                    else if(j == 3) {
                        ThLocalMoved = movemesh(ThLocal, [x + 1, y + 1]);
                        touch[3] = 1;
                    }
                }
                if(j == 3) {
                    if(touch[0] == 1 && touch[2] == 1) {
                        mesh3 ThLocalMovedSecond = movemesh(ThLocal, [x, y - 2]);
                        ThLocalMoved = ThLocalMoved + ThLocalMovedSecond;
                    }
                    if(touch[0] == 1 && touch[3] == 1) {
                        mesh3 ThLocalMovedSecond = movemesh(ThLocal, [x + 2, y]);
                        ThLocalMoved = ThLocalMoved + ThLocalMovedSecond;
                    }
                    if(touch[1] == 1 && touch[2] == 1) {
                        mesh3 ThLocalMovedSecond = movemesh(ThLocal, [x - 2, y]);
                        ThLocalMoved = ThLocalMoved + ThLocalMovedSecond;
                    }
                    if(touch[1] == 1 && touch[3] == 1) {
                        mesh3 ThLocalMovedSecond = movemesh(ThLocal, [x, y + 2]);
                        ThLocalMoved = ThLocalMoved + ThLocalMovedSecond;
                    }
                }
                if(ThLocalMoved.nt > 0) {
                    real[int] backup = partExtended[];
                    ThLocalMoved = trunc(ThLocalMoved, y <= 1-x+ThLocalMoved.hmax && y >= -1-x-ThLocalMoved.hmax && y <= 1+x+ThLocalMoved.hmax && y >= -1+x-ThLocalMoved.hmax);
                    ThExtended = ThExtended + ThLocalMoved;
                    partExtended = 0;
                    partExtended[](0:ThExtended.nt - ThLocalMoved.nt - 1) = backup;
                    partExtended[](ThExtended.nt - ThLocalMoved.nt:ThExtended.nt - 1) = i;
                }
            }
        }
        Th = ThExtended;
        part = partExtended;
    }
    broadcast(processor(0), Th);
    broadcast(processor(0), part[]);
    plot(part, fill = 1, wait = 1);
    int[int][int] intersection;
    real[int] D;
    buildWithPartitioning(ThExtended, part[], s, intersection, D, PkNoPeriodic, mpiCommWorld);
    Th = trunc(ThExtended, y <= 1-x && y >= -1-x && y <= 1+x && y >= -1+x);
    fespace WhExtended(ThExtended, PkNoPeriodic);
    matrix R = interpolate(Wh, WhExtended);
    periodicity(R, intersection, D);
    constructor(A, D.n, intersection, D);
}
else {
    if(s > 1)
        Th = trunc(Th, 1, split = s);
    fespace Wh(Th, Pk);
    constructor(A, Wh.ndof);
}
//


//-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
// COMPUTATION
//-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.

// BOUNDARY CONDITIONS -> DEFINES: deltaUZero
include "deltaUZero.idp"

macro fillA() /* A = Stiffness Matrix */ 
{ /* Fill Stiffness Matrix A */
    varf a(u, v) = H1(u, v, Th) + deltaUZeroPeriodic(u);

    INFO("initiate structure for partitioning matrix")
    MatCreate(Th, A, Pk);
    INFO("fill stiffness matrix")
    A = a(Vh, Vh, tgv = -2);

    set(A, sparams = "-pc_type gamg -ksp_type cg -ksp_rtol "+ string(solverEps));
    /*set(A, sparams = "-pc_type hpddm -ksp_type gmres -ksp_rtol "+ string(solverEps));*/

    INFO("fill stiffness matrix done")
}//

macro fillWLl(theta)
{
    /* set none zero dirchlet condition */
    varf bndDirichlet(unused, v) = deltaUZeroPeriodic(unused) + on(theta + 7, unused = 1); 
    
    wh[] = bndDirichlet(0, Vh, tgv = -1); 

    W(INDC(theta)) = wh[];

    /* compute rhs of weak formulation */
    varf rhs(unused, v) = -H1(wh, v, Th) + deltaUZeroPeriodic(unused); 
    
    l = rhs(0, Vh, tgv = -1); 

    /* for computation of capacitance needed */
    varf lBndVarf(unused, v) = H1(wh, v, Th); 
    
    L(INDC(theta)) = lBndVarf(0, Vh, tgv = -1);
}//

macro solveU(theta) 
{
    real[int] temp = A^-1 * l;
    U(INDC(theta)) = temp;
}//


macro writeCap(theta1, theta2)
{
    real[int] temp = A * U(INDC(theta2));
    
    real U1U2 = A(U(INDC(theta1)), temp); real W1L2 = A(W(INDC(theta1)), L(INDC(theta2)));

    Cap[ theta2 - theta1 ] = 1.0 / (4 * pi) * (W1L2 - U1U2);
}//

//-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
// AUXILIARY FUNCTIONS
//-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.

func bool writeOutArray( ofstream &file, real[int] &V ){
    int last = V.n;
    for [ i,v : V ] {
        file << v; 
        if( i == last-1 ) file << endl; else file << ","; 
    }
    return true;
}

macro initRecord(varName)
    string dataPath#varName = outputDir + "/" + Stringification( varName ) + "_" + outputName + ".log";
    ofstream streamLog#varName(dataPath#VarName);
    streamLog#varName.precision(16);
//

macro recordVar(varName, var)
{
    ofstream streamLog#varName(dataPath#VarName);
    streamLog#varName.precision(16);
    writeOutArray(streamLog#varName, var);
}//

macro record 
{
    recordVar(cap, Cap);
}//
